plugins {
    id 'com.android.library'
    id 'maven-publish'
    id 'org.jetbrains.dokka'
    id 'signing'
}

group = 'com.onemillionworlds'
version = project.version

repositories {
    mavenCentral()
    mavenLocal()
    google()
}

dependencies {
    api libs.openxr.bindings.native
    api project(':tamarin-core')

    compileOnly libs.jme3.core
    compileOnly libs.jme3.android

    testImplementation platform('org.junit:junit-bom:5.10.0')
    testImplementation 'org.junit.jupiter:junit-jupiter'
}

android {
    namespace 'com.onemillionworlds.tamarin.android'
    compileSdk 35

    defaultConfig {
        minSdk 24
        targetSdk 35
    }

    compileOptions {
        sourceCompatibility JavaVersion.VERSION_17
        targetCompatibility JavaVersion.VERSION_17
    }

    tasks.withType(JavaCompile).configureEach {
        javaCompiler = javaToolchains.compilerFor {
            languageVersion = JavaLanguageVersion.of(17)
        }
    }

    publishing {
        singleVariant("release") {
            withSourcesJar()
            // Javadoc jar is produced via Dokka (see javadocJar task below)
        }
    }
}

// Dokka Javadoc jar task to package HTML docs as a classifier 'javadoc'
tasks.register('javadocJar', Jar) {
    // Dokka V2 default task name is 'dokkaGeneratePublicationHtml'
    def dokkaTaskName = 'dokkaGeneratePublicationHtml'
    dependsOn tasks.named(dokkaTaskName)
    from tasks.named(dokkaTaskName).get().outputDirectory
    archiveClassifier.set('javadoc')
}

afterEvaluate {
    publishing {
        publications {

            release(MavenPublication) {
                groupId = group
                artifactId = 'tamarin-android'
                version = version

                from components.release
                artifact tasks.named('javadocJar').get()

                pom {
                    name = 'Tamarin Android'
                    description = 'VR library for JMonkeyEngine'
                    url = 'https://github.com/oneMillionWorlds/Tamarin'
                    licenses {
                        license {
                            name = 'New BSD (3-clause) License'
                            url = 'http://opensource.org/licenses/BSD-3-Clause'
                        }
                    }
                    scm {
                        connection = 'git@github.com:oneMillionWorlds/Tamarin.git'
                        developerConnection = 'git@github.com:oneMillionWorlds/Tamarin.git'
                        url = 'https://github.com/oneMillionWorlds/Tamarin'
                    }
                    developers {
                        developer {
                            id = 'RichardTingle'
                            name = 'Richard Tingle (aka richtea)'
                            email = 'support@oneMillionWorlds.com'
                        }
                    }
                }
            }
        }
        repositories {
            mavenLocal()
            maven {
                name = 'CentralPortalStaging'
                url = uri("${rootProject.buildDir}/central-portal-staging")
            }
        }
    }
}


// Signing configuration for Android publication
signing {
    // Fallback: inject signing.keyId from environment if not provided via properties
    if (!project.hasProperty('signing.keyId')) {
        def envKeyId = System.getenv('SIGNING_KEY_ID')
        if (envKeyId && envKeyId.trim()) {
            project.ext.set('signing.keyId', envKeyId.trim())
            logger.lifecycle("[Signing Debug] Applied signing.keyId from SIGNING_KEY_ID env var")
        } else {
            logger.lifecycle("[Signing Debug] No SIGNING_KEY_ID env var found")
        }
    }
    def ringFileProp = findProperty('signing.secretKeyRingFile')
    def keyId = findProperty('signing.keyId')
    def passSet = project.hasProperty('signing.password')
    if (ringFileProp) {
        def f = file(ringFileProp)
        logger.lifecycle("[Signing Debug] secretKeyRingFile='${f}' exists=${f.exists()} keyIdSet=${keyId != null} passSet=${passSet}")
    } else {
        logger.lifecycle("[Signing Debug] secretKeyRingFile is NOT set. keyIdSet=${keyId != null} passSet=${passSet}")
    }
    // Sign all publications to avoid configuration-time lookup issues
    sign publishing.publications
}
